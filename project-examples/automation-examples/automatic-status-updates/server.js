/**
 * Automatic Status Updates Service Server
 * Express server for automatic task status updates
 */

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const compression = require('compression');
const rateLimit = require('express-rate-limit');
const winston = require('winston');

const IntegratedStatusUpdateSystem = require('./integrated-status-update-system');

// Initialize Express app
const app = express();
const PORT = process.env.PORT || 3013;

// Configure logging
const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
    ),
    transports: [
        new winston.transports.Console(),
        new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
        new winston.transports.File({ filename: 'logs/combined.log' })
    ]
});

// Initialize integrated status update system
const statusUpdateSystem = new IntegratedStatusUpdateSystem({
    statusUpdate: {
        autoDetection: true,
        smartUpdates: true,
        conflictResolution: true,
        notificationEnabled: true,
        auditTrail: true,
        rollbackEnabled: true
    },
    ai: {
        modelType: 'ensemble',
        learningRate: 0.01,
        predictionAccuracy: 0.85,
        contextWindow: 30
    },
    monitoring: {
        realTimeUpdates: true,
        alertThresholds: {
            updateDelay: 300, // 5 minutes
            conflictRate: 0.1,
            errorRate: 0.05
        }
    },
    autoUpdates: true,
    aiEnabled: true,
    monitoringEnabled: true
});

// Middleware
app.use(helmet());
app.use(cors());
app.use(compression());
app.use(morgan('combined', { stream: { write: message => logger.info(message.trim()) } }));

// Rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 1000 // limit each IP to 1000 requests per windowMs
});
app.use(limiter);

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Health check endpoint
app.get('/health', (req, res) => {
    res.status(200).json({
        status: 'healthy',
        service: 'automatic-status-updates',
        version: '2.4.0',
        timestamp: new Date().toISOString(),
        uptime: process.uptime()
    });
});

// API routes
app.post('/api/status-updates', async (req, res) => {
    try {
        const { taskId, newStatus, reason, metadata = {} } = req.body;
        
        if (!taskId || !newStatus) {
            return res.status(400).json({
                success: false,
                error: 'TaskId and newStatus are required'
            });
        }
        
        const result = await statusUpdateSystem.updateTaskStatus(taskId, newStatus, {
            reason,
            metadata,
            autoGenerated: false
        });
        
        res.json({
            success: true,
            result,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        logger.error('Error updating task status:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to update task status',
            message: error.message
        });
    }
});

app.get('/api/status-updates/:taskId', (req, res) => {
    try {
        const { taskId } = req.params;
        const { includeHistory = false, limit = 50 } = req.query;
        
        const statusUpdates = statusUpdateSystem.getTaskStatusUpdates(taskId, {
            includeHistory: includeHistory === 'true',
            limit: parseInt(limit)
        });
        
        res.json({
            success: true,
            statusUpdates,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        logger.error('Error getting task status updates:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to get task status updates',
            message: error.message
        });
    }
});

app.post('/api/status-updates/bulk', async (req, res) => {
    try {
        const { updates, options = {} } = req.body;
        
        if (!updates || !Array.isArray(updates)) {
            return res.status(400).json({
                success: false,
                error: 'Updates array is required'
            });
        }
        
        const results = await statusUpdateSystem.bulkUpdateStatus(updates, options);
        
        res.json({
            success: true,
            results,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        logger.error('Error bulk updating status:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to bulk update status',
            message: error.message
        });
    }
});

app.post('/api/status-updates/auto', async (req, res) => {
    try {
        const { taskIds, projectId, options = {} } = req.body;
        
        const results = await statusUpdateSystem.autoUpdateStatus(taskIds, {
            projectId,
            ...options
        });
        
        res.json({
            success: true,
            results,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        logger.error('Error auto updating status:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to auto update status',
            message: error.message
        });
    }
});

app.get('/api/status-updates/history', (req, res) => {
    try {
        const { 
            taskId, 
            projectId, 
            status, 
            startDate, 
            endDate, 
            limit = 100, 
            offset = 0 
        } = req.query;
        
        const history = statusUpdateSystem.getStatusHistory({
            taskId,
            projectId,
            status,
            startDate: startDate ? new Date(startDate) : null,
            endDate: endDate ? new Date(endDate) : null,
            limit: parseInt(limit),
            offset: parseInt(offset)
        });
        
        res.json({
            success: true,
            history,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        logger.error('Error getting status history:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to get status history',
            message: error.message
        });
    }
});

app.post('/api/status-updates/rollback', async (req, res) => {
    try {
        const { taskId, updateId, reason } = req.body;
        
        if (!taskId || !updateId) {
            return res.status(400).json({
                success: false,
                error: 'TaskId and updateId are required'
            });
        }
        
        const result = await statusUpdateSystem.rollbackStatusUpdate(taskId, updateId, {
            reason
        });
        
        res.json({
            success: true,
            result,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        logger.error('Error rolling back status update:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to rollback status update',
            message: error.message
        });
    }
});

app.get('/api/status-updates/conflicts', (req, res) => {
    try {
        const { taskId, projectId } = req.query;
        
        const conflicts = statusUpdateSystem.getStatusConflicts({
            taskId,
            projectId
        });
        
        res.json({
            success: true,
            conflicts,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        logger.error('Error getting status conflicts:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to get status conflicts',
            message: error.message
        });
    }
});

app.post('/api/status-updates/resolve-conflicts', async (req, res) => {
    try {
        const { conflicts, resolutionStrategy = 'auto' } = req.body;
        
        if (!conflicts || !Array.isArray(conflicts)) {
            return res.status(400).json({
                success: false,
                error: 'Conflicts array is required'
            });
        }
        
        const results = await statusUpdateSystem.resolveStatusConflicts(conflicts, {
            resolutionStrategy
        });
        
        res.json({
            success: true,
            results,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        logger.error('Error resolving status conflicts:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to resolve status conflicts',
            message: error.message
        });
    }
});

app.get('/api/status-updates/analytics', (req, res) => {
    try {
        const { 
            projectId, 
            startDate, 
            endDate, 
            groupBy = 'day' 
        } = req.query;
        
        const analytics = statusUpdateSystem.getStatusAnalytics({
            projectId,
            startDate: startDate ? new Date(startDate) : null,
            endDate: endDate ? new Date(endDate) : null,
            groupBy
        });
        
        res.json({
            success: true,
            analytics,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        logger.error('Error getting status analytics:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to get status analytics',
            message: error.message
        });
    }
});

app.get('/api/status-updates/patterns', (req, res) => {
    try {
        const { projectId, taskType, timeRange = '30d' } = req.query;
        
        const patterns = statusUpdateSystem.analyzeStatusPatterns({
            projectId,
            taskType,
            timeRange
        });
        
        res.json({
            success: true,
            patterns,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        logger.error('Error analyzing status patterns:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to analyze status patterns',
            message: error.message
        });
    }
});

app.post('/api/status-updates/predict', async (req, res) => {
    try {
        const { taskId, currentStatus, context = {} } = req.body;
        
        if (!taskId || !currentStatus) {
            return res.status(400).json({
                success: false,
                error: 'TaskId and currentStatus are required'
            });
        }
        
        const prediction = await statusUpdateSystem.predictNextStatus(taskId, currentStatus, context);
        
        res.json({
            success: true,
            prediction,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        logger.error('Error predicting next status:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to predict next status',
            message: error.message
        });
    }
});

app.get('/api/status-updates/rules', (req, res) => {
    try {
        const { projectId, status } = req.query;
        
        const rules = statusUpdateSystem.getStatusRules({
            projectId,
            status
        });
        
        res.json({
            success: true,
            rules,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        logger.error('Error getting status rules:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to get status rules',
            message: error.message
        });
    }
});

app.post('/api/status-updates/rules', (req, res) => {
    try {
        const { rule } = req.body;
        
        const createdRule = statusUpdateSystem.createStatusRule(rule);
        
        res.json({
            success: true,
            rule: createdRule,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        logger.error('Error creating status rule:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to create status rule',
            message: error.message
        });
    }
});

app.get('/api/system/status', (req, res) => {
    try {
        const status = {
            isRunning: statusUpdateSystem.isRunning,
            lastUpdate: statusUpdateSystem.lastUpdate,
            totalUpdates: statusUpdateSystem.getTotalUpdates(),
            activeTasks: statusUpdateSystem.getActiveTasks().length,
            pendingUpdates: statusUpdateSystem.getPendingUpdates().length,
            conflicts: statusUpdateSystem.getConflicts().length,
            uptime: process.uptime()
        };
        
        res.json({
            success: true,
            status,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        logger.error('Error getting system status:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to retrieve system status',
            message: error.message
        });
    }
});

// Error handling middleware
app.use((error, req, res, next) => {
    logger.error('Unhandled error:', error);
    res.status(500).json({
        success: false,
        error: 'Internal server error',
        message: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong'
    });
});

// 404 handler
app.use('*', (req, res) => {
    res.status(404).json({
        success: false,
        error: 'Endpoint not found',
        path: req.originalUrl,
        method: req.method
    });
});

// Start server
app.listen(PORT, '0.0.0.0', () => {
    logger.info(`Automatic Status Updates Service running on port ${PORT}`);
    logger.info(`Environment: ${process.env.NODE_ENV || 'development'}`);
    logger.info(`AI Updates enabled: ${statusUpdateSystem.config.aiEnabled}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
    logger.info('SIGTERM received, shutting down gracefully');
    statusUpdateSystem.stop();
    process.exit(0);
});

process.on('SIGINT', () => {
    logger.info('SIGINT received, shutting down gracefully');
    statusUpdateSystem.stop();
    process.exit(0);
});

module.exports = app;
