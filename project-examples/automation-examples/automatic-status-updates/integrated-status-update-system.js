/**
 * Integrated Status Update System
 * Orchestrates AI-powered automatic task status updates
 */

const StatusUpdateEngine = require('./status-update-engine');
const ConflictResolver = require('./conflict-resolver');
const PatternAnalyzer = require('./pattern-analyzer');
const PredictionEngine = require('./prediction-engine');

class IntegratedStatusUpdateSystem {
    constructor(options = {}) {
        this.statusUpdateEngine = new StatusUpdateEngine(options.statusUpdate);
        this.conflictResolver = new ConflictResolver(options.statusUpdate);
        this.patternAnalyzer = new PatternAnalyzer(options.ai);
        this.predictionEngine = new PredictionEngine(options.ai);
        
        this.isRunning = true;
        this.lastUpdate = new Date();
        this.statusUpdates = new Map();
        this.tasks = new Map();
        this.projects = new Map();
        this.rules = new Map();
        this.analytics = new Map();
        
        this.config = {
            autoUpdates: options.autoUpdates || false,
            aiEnabled: options.aiEnabled || false,
            monitoringEnabled: options.monitoringEnabled || false,
            ...options
        };
        
        this.initializeDefaultRules();
        this.startBackgroundProcesses();
    }

    /**
     * Update task status
     */
    async updateTaskStatus(taskId, newStatus, options = {}) {
        try {
            const { reason, metadata = {}, autoGenerated = false } = options;
            
            // Validate status transition
            const currentStatus = this.getCurrentTaskStatus(taskId);
            const isValidTransition = this.validateStatusTransition(currentStatus, newStatus);
            
            if (!isValidTransition) {
                throw new Error(`Invalid status transition from ${currentStatus} to ${newStatus}`);
            }
            
            // Check for conflicts
            const conflicts = this.checkStatusConflicts(taskId, newStatus);
            
            // Create status update
            const statusUpdate = {
                id: this.generateUpdateId(taskId),
                taskId,
                previousStatus: currentStatus,
                newStatus,
                reason,
                metadata,
                autoGenerated,
                timestamp: new Date(),
                conflicts
            };
            
            // Apply status update
            const result = await this.statusUpdateEngine.applyStatusUpdate(statusUpdate);
            
            // Store update
            this.statusUpdates.set(statusUpdate.id, statusUpdate);
            
            // Update task status
            this.updateTaskStatusInMemory(taskId, newStatus);
            
            // Resolve conflicts if any
            if (conflicts.length > 0 && this.config.autoUpdates) {
                await this.autoResolveConflicts(conflicts);
            }
            
            // Update analytics
            this.updateAnalytics('status_updated', statusUpdate);
            
            // Notify if enabled
            if (this.config.statusUpdate.notificationEnabled) {
                await this.notifyStatusUpdate(statusUpdate);
            }
            
            return {
                success: true,
                statusUpdate,
                conflicts,
                result
            };
        } catch (error) {
            console.error('Error updating task status:', error);
            throw error;
        }
    }

    /**
     * Get task status updates
     */
    getTaskStatusUpdates(taskId, options = {}) {
        const { includeHistory = false, limit = 50 } = options;
        
        let updates = Array.from(this.statusUpdates.values())
            .filter(update => update.taskId === taskId)
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        if (!includeHistory) {
            updates = updates.slice(0, 1); // Only current status
        }
        
        return updates.slice(0, limit);
    }

    /**
     * Bulk update status
     */
    async bulkUpdateStatus(updates, options = {}) {
        try {
            const results = [];
            const { validateTransitions = true, resolveConflicts = true } = options;
            
            for (const update of updates) {
                try {
                    const result = await this.updateTaskStatus(
                        update.taskId, 
                        update.newStatus, 
                        {
                            reason: update.reason,
                            metadata: update.metadata,
                            autoGenerated: update.autoGenerated || false
                        }
                    );
                    results.push({ success: true, ...result });
                } catch (error) {
                    results.push({ 
                        success: false, 
                        taskId: update.taskId, 
                        error: error.message 
                    });
                }
            }
            
            return {
                totalUpdates: updates.length,
                successfulUpdates: results.filter(r => r.success).length,
                failedUpdates: results.filter(r => !r.success).length,
                results
            };
        } catch (error) {
            console.error('Error bulk updating status:', error);
            throw error;
        }
    }

    /**
     * Auto update status
     */
    async autoUpdateStatus(taskIds, options = {}) {
        try {
            const { projectId } = options;
            const results = [];
            
            for (const taskId of taskIds) {
                try {
                    // Analyze task context
                    const context = await this.analyzeTaskContext(taskId, { projectId });
                    
                    // Predict next status
                    const currentStatus = this.getCurrentTaskStatus(taskId);
                    const predictedStatus = await this.predictionEngine.predictNextStatus(
                        taskId, 
                        currentStatus, 
                        context
                    );
                    
                    if (predictedStatus && predictedStatus !== currentStatus) {
                        const result = await this.updateTaskStatus(taskId, predictedStatus, {
                            reason: 'Auto-generated based on AI analysis',
                            metadata: { 
                                prediction: predictedStatus,
                                confidence: context.confidence,
                                autoGenerated: true
                            },
                            autoGenerated: true
                        });
                        results.push({ success: true, taskId, ...result });
                    } else {
                        results.push({ 
                            success: true, 
                            taskId, 
                            message: 'No status change needed' 
                        });
                    }
                } catch (error) {
                    results.push({ 
                        success: false, 
                        taskId, 
                        error: error.message 
                    });
                }
            }
            
            return {
                totalTasks: taskIds.length,
                updatedTasks: results.filter(r => r.success && r.statusUpdate).length,
                unchangedTasks: results.filter(r => r.success && !r.statusUpdate).length,
                failedTasks: results.filter(r => !r.success).length,
                results
            };
        } catch (error) {
            console.error('Error auto updating status:', error);
            throw error;
        }
    }

    /**
     * Get status history
     */
    getStatusHistory(filters = {}) {
        const {
            taskId,
            projectId,
            status,
            startDate,
            endDate,
            limit = 100,
            offset = 0
        } = filters;
        
        let history = Array.from(this.statusUpdates.values());
        
        // Apply filters
        if (taskId) {
            history = history.filter(update => update.taskId === taskId);
        }
        
        if (projectId) {
            const projectTasks = this.getProjectTasks(projectId);
            history = history.filter(update => projectTasks.includes(update.taskId));
        }
        
        if (status) {
            history = history.filter(update => update.newStatus === status);
        }
        
        if (startDate) {
            history = history.filter(update => new Date(update.timestamp) >= startDate);
        }
        
        if (endDate) {
            history = history.filter(update => new Date(update.timestamp) <= endDate);
        }
        
        // Sort by timestamp (newest first)
        history.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        // Apply pagination
        return history.slice(offset, offset + limit);
    }

    /**
     * Rollback status update
     */
    async rollbackStatusUpdate(taskId, updateId, options = {}) {
        try {
            const { reason } = options;
            
            const statusUpdate = this.statusUpdates.get(updateId);
            if (!statusUpdate || statusUpdate.taskId !== taskId) {
                throw new Error('Status update not found');
            }
            
            // Create rollback update
            const rollbackUpdate = {
                id: this.generateUpdateId(taskId),
                taskId,
                previousStatus: statusUpdate.newStatus,
                newStatus: statusUpdate.previousStatus,
                reason: reason || 'Rollback of previous update',
                metadata: {
                    rollbackOf: updateId,
                    originalUpdate: statusUpdate,
                    rollbackReason: reason
                },
                autoGenerated: false,
                timestamp: new Date(),
                conflicts: []
            };
            
            // Apply rollback
            const result = await this.statusUpdateEngine.applyStatusUpdate(rollbackUpdate);
            
            // Store rollback update
            this.statusUpdates.set(rollbackUpdate.id, rollbackUpdate);
            
            // Update task status
            this.updateTaskStatusInMemory(taskId, statusUpdate.previousStatus);
            
            // Update analytics
            this.updateAnalytics('status_rollback', rollbackUpdate);
            
            return {
                success: true,
                rollbackUpdate,
                result
            };
        } catch (error) {
            console.error('Error rolling back status update:', error);
            throw error;
        }
    }

    /**
     * Get status conflicts
     */
    getStatusConflicts(filters = {}) {
        const { taskId, projectId } = filters;
        
        let conflicts = Array.from(this.statusUpdates.values())
            .filter(update => update.conflicts && update.conflicts.length > 0)
            .flatMap(update => update.conflicts);
        
        if (taskId) {
            conflicts = conflicts.filter(conflict => conflict.taskId === taskId);
        }
        
        if (projectId) {
            const projectTasks = this.getProjectTasks(projectId);
            conflicts = conflicts.filter(conflict => projectTasks.includes(conflict.taskId));
        }
        
        return conflicts;
    }

    /**
     * Resolve status conflicts
     */
    async resolveStatusConflicts(conflicts, options = {}) {
        try {
            const { resolutionStrategy = 'auto' } = options;
            const results = [];
            
            for (const conflict of conflicts) {
                try {
                    const resolution = await this.conflictResolver.resolveConflict(
                        conflict, 
                        resolutionStrategy
                    );
                    
                    if (resolution) {
                        results.push({
                            conflictId: conflict.id,
                            resolution,
                            success: true
                        });
                    } else {
                        results.push({
                            conflictId: conflict.id,
                            success: false,
                            error: 'No resolution found'
                        });
                    }
                } catch (error) {
                    results.push({
                        conflictId: conflict.id,
                        success: false,
                        error: error.message
                    });
                }
            }
            
            return {
                totalConflicts: conflicts.length,
                resolvedConflicts: results.filter(r => r.success).length,
                failedResolutions: results.filter(r => !r.success).length,
                results
            };
        } catch (error) {
            console.error('Error resolving status conflicts:', error);
            throw error;
        }
    }

    /**
     * Get status analytics
     */
    getStatusAnalytics(filters = {}) {
        const { projectId, startDate, endDate, groupBy = 'day' } = filters;
        
        let updates = Array.from(this.statusUpdates.values());
        
        // Apply filters
        if (projectId) {
            const projectTasks = this.getProjectTasks(projectId);
            updates = updates.filter(update => projectTasks.includes(update.taskId));
        }
        
        if (startDate) {
            updates = updates.filter(update => new Date(update.timestamp) >= startDate);
        }
        
        if (endDate) {
            updates = updates.filter(update => new Date(update.timestamp) <= endDate);
        }
        
        // Group by time period
        const groupedUpdates = this.groupUpdatesByTime(updates, groupBy);
        
        // Calculate analytics
        const analytics = {
            totalUpdates: updates.length,
            autoGeneratedUpdates: updates.filter(u => u.autoGenerated).length,
            manualUpdates: updates.filter(u => !u.autoGenerated).length,
            statusDistribution: this.calculateStatusDistribution(updates),
            updateFrequency: this.calculateUpdateFrequency(groupedUpdates),
            conflictRate: this.calculateConflictRate(updates),
            rollbackRate: this.calculateRollbackRate(updates),
            averageUpdateTime: this.calculateAverageUpdateTime(updates),
            trends: this.calculateTrends(groupedUpdates)
        };
        
        return analytics;
    }

    /**
     * Analyze status patterns
     */
    analyzeStatusPatterns(filters = {}) {
        const { projectId, taskType, timeRange = '30d' } = filters;
        
        let updates = Array.from(this.statusUpdates.values());
        
        // Apply filters
        if (projectId) {
            const projectTasks = this.getProjectTasks(projectId);
            updates = updates.filter(update => projectTasks.includes(update.taskId));
        }
        
        if (taskType) {
            updates = updates.filter(update => {
                const task = this.tasks.get(update.taskId);
                return task && task.type === taskType;
            });
        }
        
        // Analyze patterns
        const patterns = {
            commonTransitions: this.findCommonTransitions(updates),
            statusDurations: this.calculateStatusDurations(updates),
            updatePatterns: this.findUpdatePatterns(updates),
            seasonalPatterns: this.findSeasonalPatterns(updates),
            anomalyPatterns: this.findAnomalyPatterns(updates)
        };
        
        return patterns;
    }

    /**
     * Predict next status
     */
    async predictNextStatus(taskId, currentStatus, context = {}) {
        try {
            const prediction = await this.predictionEngine.predictNextStatus(
                taskId, 
                currentStatus, 
                context
            );
            
            return prediction;
        } catch (error) {
            console.error('Error predicting next status:', error);
            return null;
        }
    }

    /**
     * Get status rules
     */
    getStatusRules(filters = {}) {
        const { projectId, status } = filters;
        
        let rules = Array.from(this.rules.values());
        
        if (projectId) {
            rules = rules.filter(rule => !rule.projectId || rule.projectId === projectId);
        }
        
        if (status) {
            rules = rules.filter(rule => rule.status === status);
        }
        
        return rules;
    }

    /**
     * Create status rule
     */
    createStatusRule(rule) {
        const newRule = {
            id: this.generateRuleId(),
            ...rule,
            createdAt: new Date(),
            isActive: true
        };
        
        this.rules.set(newRule.id, newRule);
        
        return newRule;
    }

    /**
     * Get current task status
     */
    getCurrentTaskStatus(taskId) {
        const task = this.tasks.get(taskId);
        return task ? task.status : 'unknown';
    }

    /**
     * Validate status transition
     */
    validateStatusTransition(currentStatus, newStatus) {
        const validTransitions = {
            'pending': ['in_progress', 'cancelled'],
            'in_progress': ['completed', 'cancelled', 'on_hold'],
            'on_hold': ['in_progress', 'cancelled'],
            'completed': ['in_progress'], // Reopening
            'cancelled': ['pending', 'in_progress'] // Reactivation
        };
        
        const allowedStatuses = validTransitions[currentStatus] || [];
        return allowedStatuses.includes(newStatus);
    }

    /**
     * Check status conflicts
     */
    checkStatusConflicts(taskId, newStatus) {
        const conflicts = [];
        
        // Check for dependency conflicts
        const dependencies = this.getTaskDependencies(taskId);
        for (const depId of dependencies) {
            const depStatus = this.getCurrentTaskStatus(depId);
            if (depStatus === 'pending' && newStatus === 'completed') {
                conflicts.push({
                    type: 'dependency',
                    taskId: depId,
                    message: 'Cannot complete task with pending dependencies',
                    severity: 'high'
                });
            }
        }
        
        // Check for resource conflicts
        const resourceConflicts = this.checkResourceConflicts(taskId, newStatus);
        conflicts.push(...resourceConflicts);
        
        return conflicts;
    }

    /**
     * Check resource conflicts
     */
    checkResourceConflicts(taskId, newStatus) {
        // This would typically check resource allocation
        // For now, return empty array
        return [];
    }

    /**
     * Get task dependencies
     */
    getTaskDependencies(taskId) {
        // This would typically query a dependency management system
        // For now, return empty array
        return [];
    }

    /**
     * Get project tasks
     */
    getProjectTasks(projectId) {
        // This would typically query a task management system
        // For now, return mock data
        return ['task_1', 'task_2', 'task_3', 'task_4', 'task_5'];
    }

    /**
     * Update task status in memory
     */
    updateTaskStatusInMemory(taskId, newStatus) {
        if (!this.tasks.has(taskId)) {
            this.tasks.set(taskId, { id: taskId, status: newStatus });
        } else {
            this.tasks.get(taskId).status = newStatus;
        }
    }

    /**
     * Analyze task context
     */
    async analyzeTaskContext(taskId, options = {}) {
        const { projectId } = options;
        
        // This would typically analyze task context using AI
        // For now, return mock analysis
        return {
            taskId,
            projectId,
            complexity: 'medium',
            priority: 'high',
            dependencies: this.getTaskDependencies(taskId),
            resources: ['developer_1'],
            confidence: 0.85
        };
    }

    /**
     * Auto resolve conflicts
     */
    async autoResolveConflicts(conflicts) {
        for (const conflict of conflicts) {
            try {
                await this.conflictResolver.resolveConflict(conflict, 'auto');
            } catch (error) {
                console.error('Error auto-resolving conflict:', error);
            }
        }
    }

    /**
     * Notify status update
     */
    async notifyStatusUpdate(statusUpdate) {
        // This would typically send notifications
        console.log(`Status update notification: ${statusUpdate.taskId} -> ${statusUpdate.newStatus}`);
    }

    /**
     * Group updates by time
     */
    groupUpdatesByTime(updates, groupBy) {
        const groups = new Map();
        
        for (const update of updates) {
            const date = new Date(update.timestamp);
            let key;
            
            switch (groupBy) {
                case 'hour':
                    key = date.toISOString().slice(0, 13);
                    break;
                case 'day':
                    key = date.toISOString().slice(0, 10);
                    break;
                case 'week':
                    const week = this.getWeekNumber(date);
                    key = `${date.getFullYear()}-W${week}`;
                    break;
                case 'month':
                    key = date.toISOString().slice(0, 7);
                    break;
                default:
                    key = date.toISOString().slice(0, 10);
            }
            
            if (!groups.has(key)) {
                groups.set(key, []);
            }
            groups.get(key).push(update);
        }
        
        return groups;
    }

    /**
     * Get week number
     */
    getWeekNumber(date) {
        const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
        const dayNum = d.getUTCDay() || 7;
        d.setUTCDate(d.getUTCDate() + 4 - dayNum);
        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    }

    /**
     * Calculate status distribution
     */
    calculateStatusDistribution(updates) {
        const distribution = {};
        
        for (const update of updates) {
            const status = update.newStatus;
            distribution[status] = (distribution[status] || 0) + 1;
        }
        
        return distribution;
    }

    /**
     * Calculate update frequency
     */
    calculateUpdateFrequency(groupedUpdates) {
        const frequencies = {};
        
        for (const [key, updates] of groupedUpdates) {
            frequencies[key] = updates.length;
        }
        
        return frequencies;
    }

    /**
     * Calculate conflict rate
     */
    calculateConflictRate(updates) {
        const totalUpdates = updates.length;
        const conflictedUpdates = updates.filter(u => u.conflicts && u.conflicts.length > 0).length;
        
        return totalUpdates > 0 ? conflictedUpdates / totalUpdates : 0;
    }

    /**
     * Calculate rollback rate
     */
    calculateRollbackRate(updates) {
        const totalUpdates = updates.length;
        const rollbackUpdates = updates.filter(u => u.metadata && u.metadata.rollbackOf).length;
        
        return totalUpdates > 0 ? rollbackUpdates / totalUpdates : 0;
    }

    /**
     * Calculate average update time
     */
    calculateAverageUpdateTime(updates) {
        if (updates.length === 0) return 0;
        
        const totalTime = updates.reduce((sum, update) => {
            const updateTime = new Date(update.timestamp).getTime();
            return sum + updateTime;
        }, 0);
        
        return totalTime / updates.length;
    }

    /**
     * Calculate trends
     */
    calculateTrends(groupedUpdates) {
        const trends = {};
        
        for (const [key, updates] of groupedUpdates) {
            const statusDistribution = this.calculateStatusDistribution(updates);
            trends[key] = statusDistribution;
        }
        
        return trends;
    }

    /**
     * Find common transitions
     */
    findCommonTransitions(updates) {
        const transitions = {};
        
        for (const update of updates) {
            const transition = `${update.previousStatus} -> ${update.newStatus}`;
            transitions[transition] = (transitions[transition] || 0) + 1;
        }
        
        return transitions;
    }

    /**
     * Calculate status durations
     */
    calculateStatusDurations(updates) {
        // This would calculate how long tasks spend in each status
        // For now, return mock data
        return {
            'pending': 2.5, // days
            'in_progress': 5.2,
            'completed': 0.1,
            'cancelled': 1.0
        };
    }

    /**
     * Find update patterns
     */
    findUpdatePatterns(updates) {
        // This would analyze patterns in status updates
        // For now, return mock data
        return {
            peakHours: [9, 10, 14, 15],
            peakDays: ['Monday', 'Tuesday', 'Wednesday'],
            commonReasons: ['Progress update', 'Dependency resolved', 'Review completed']
        };
    }

    /**
     * Find seasonal patterns
     */
    findSeasonalPatterns(updates) {
        // This would analyze seasonal patterns
        // For now, return mock data
        return {
            monthlyTrends: {
                'January': 0.8,
                'February': 0.9,
                'March': 1.1,
                'April': 1.0
            }
        };
    }

    /**
     * Find anomaly patterns
     */
    findAnomalyPatterns(updates) {
        // This would detect anomalies in status updates
        // For now, return mock data
        return {
            anomalies: [
                {
                    type: 'unusual_frequency',
                    description: 'Unusually high number of status updates',
                    severity: 'medium'
                }
            ]
        };
    }

    /**
     * Generate update ID
     */
    generateUpdateId(taskId) {
        return `update_${taskId}_${Date.now()}`;
    }

    /**
     * Generate rule ID
     */
    generateRuleId() {
        return `rule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Update analytics
     */
    updateAnalytics(event, data) {
        const timestamp = new Date();
        const analytics = {
            event,
            data,
            timestamp
        };
        
        this.analytics.set(`${event}_${timestamp.getTime()}`, analytics);
        
        // Keep only last 1000 analytics entries
        if (this.analytics.size > 1000) {
            const entries = Array.from(this.analytics.entries());
            entries.sort((a, b) => new Date(a[1].timestamp) - new Date(b[1].timestamp));
            
            for (let i = 0; i < entries.length - 1000; i++) {
                this.analytics.delete(entries[i][0]);
            }
        }
    }

    /**
     * Initialize default rules
     */
    initializeDefaultRules() {
        // Auto-complete rule
        this.rules.set('auto_complete', {
            id: 'auto_complete',
            name: 'Auto Complete',
            description: 'Automatically complete tasks when all dependencies are done',
            status: 'in_progress',
            conditions: {
                allDependenciesCompleted: true,
                noBlockingIssues: true
            },
            action: 'complete',
            priority: 'medium',
            isActive: true,
            createdAt: new Date()
        });
        
        // Auto-hold rule
        this.rules.set('auto_hold', {
            id: 'auto_hold',
            name: 'Auto Hold',
            description: 'Automatically put tasks on hold when dependencies are blocked',
            status: 'in_progress',
            conditions: {
                hasBlockedDependencies: true,
                noProgressForDays: 3
            },
            action: 'hold',
            priority: 'high',
            isActive: true,
            createdAt: new Date()
        });
    }

    /**
     * Start background processes
     */
    startBackgroundProcesses() {
        // Auto-update status
        setInterval(() => {
            this.performAutoUpdates();
        }, 60000); // Every minute
        
        // Clean up old analytics
        setInterval(() => {
            this.cleanupAnalytics();
        }, 300000); // Every 5 minutes
    }

    /**
     * Perform auto updates
     */
    async performAutoUpdates() {
        if (!this.config.autoUpdates) return;
        
        try {
            const activeTasks = Array.from(this.tasks.keys());
            if (activeTasks.length > 0) {
                await this.autoUpdateStatus(activeTasks);
            }
        } catch (error) {
            console.error('Error performing auto updates:', error);
        }
    }

    /**
     * Clean up old analytics
     */
    cleanupAnalytics() {
        const cutoffTime = Date.now() - (7 * 24 * 60 * 60 * 1000); // 7 days ago
        
        for (const [key, analytics] of this.analytics) {
            if (new Date(analytics.timestamp).getTime() < cutoffTime) {
                this.analytics.delete(key);
            }
        }
    }

    /**
     * Get total updates
     */
    getTotalUpdates() {
        return this.statusUpdates.size;
    }

    /**
     * Get active tasks
     */
    getActiveTasks() {
        return Array.from(this.tasks.values()).filter(task => 
            task.status === 'in_progress' || task.status === 'pending'
        );
    }

    /**
     * Get pending updates
     */
    getPendingUpdates() {
        return Array.from(this.statusUpdates.values()).filter(update => 
            update.conflicts && update.conflicts.length > 0
        );
    }

    /**
     * Get conflicts
     */
    getConflicts() {
        return this.getStatusConflicts();
    }

    /**
     * Stop the status update system
     */
    stop() {
        this.isRunning = false;
        this.statusUpdateEngine.stop();
        this.conflictResolver.stop();
        this.patternAnalyzer.stop();
        this.predictionEngine.stop();
    }
}

module.exports = IntegratedStatusUpdateSystem;
